# Тест соответствия диаметра пучка

Набор тестов для проверки правильности расчета Z координаты на основе заданного диаметра пучка.

## 📁 Файлы

- **TestUdmBuilder.cs** - Точный C# порт Java алгоритма из `UdmProducer.java` и `BeamConfig.java`
- **DiameterVerificationTest.cs** - Набор автоматических тестов для проверки соответствия
- **RunDiameterTests.cs** - Простой интерфейс для запуска тестов
- **scanator_config_test.json** - Конфигурация сканера (ваш рабочий конфиг)

## 🚀 Быстрый запуск

### Вариант 1: Быстрый тест (одна точка)

```csharp
// В App.xaml.cs или MainWindowViewModel.cs
using HansDebuggerApp.Hans;

// Тест с диаметром 100 мкм и мощностью 200 Вт
RunDiameterTests.RunQuick(diameter: 100.0, power: 200f);

// Или с параметрами по умолчанию (100 мкм, 200 Вт)
RunDiameterTests.RunQuick();
```

### Вариант 2: Полный набор тестов

```csharp
// Запускает тесты с разными диаметрами и мощностями
RunDiameterTests.RunAll();
```

### Вариант 3: С готовой конфигурацией

```csharp
var config = ScanatorConfigurationLoader.LoadFromFile("scanator_config_test.json")[0];
RunDiameterTests.RunWithConfig(config);
```

## 📊 Что тестируется

### Тест 1: Различные диаметры при постоянной мощности
- 63.1 мкм (минимальный диаметр, фокус)
- 70 мкм (небольшая расфокусировка)
- 80 мкм (средняя расфокусировка)
- 100 мкм (большая расфокусировка)
- 120 мкм (очень большая расфокусировка)
- 150 мкм (экстремальная расфокусировка)

**Мощность:** 200 Вт

### Тест 2: Различные мощности при постоянном диаметре
- 100 Вт (низкая мощность)
- 200 Вт (средняя мощность)
- 300 Вт (высокая мощность)
- 400 Вт (очень высокая мощность)

**Диаметр:** 100 мкм

### Тест 3: Различные позиции в поле
- Центр поля (0, 0)
- +50 мм по X
- +50 мм по Y
- Угол (+50, +50)
- Дальний угол (+100, +100)

**Диаметр:** 100 мкм, **Мощность:** 200 Вт

## 📋 Вывод результатов

Каждый тест выводит:

```
┌─────────────────────────────────────────────────────────────────────┐
│ РЕЗУЛЬТАТЫ РАСЧЕТА                                                  │
├─────────────────────────────────────────────────────────────────────┤
│ Целевой диаметр: 100.0                                         мкм │
│ Мощность: 200                                                   Вт │
├─────────────────────────────────────────────────────────────────────┤
│ ПРОМЕЖУТОЧНЫЕ ЗНАЧЕНИЯ                                              │
│   Фокусное расстояние (базовое): 538.46                        мм │
│   Фокусное расстояние (после всех коррекций): 0.541199         мм │
│   Смещение от диаметра (getLensTravelMicron): 2738.621         мкм │
│   Смещение от мощности (getPowerOffset): 40.123                мкм │
├─────────────────────────────────────────────────────────────────────┤
│ ИТОГОВАЯ Z КООРДИНАТА                                               │
│   Z final: 0.002739                                             мм │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ ПРОВЕРКА СООТВЕТСТВИЯ (обратный расчет)                             │
├─────────────────────────────────────────────────────────────────────┤
│   Заданный диаметр: 100.0                                      мкм │
│   Ожидаемый диаметр при Z=0.002739 мм: 100.02                  мкм │
│   Ошибка: 0.02                                                  мкм │
│   Ошибка: 0.02                                                   % │
├─────────────────────────────────────────────────────────────────────┤
│ ✓ ОТЛИЧНО: Точность < 1 мкм                                         │
└─────────────────────────────────────────────────────────────────────┘
```

## 🔬 Как работает алгоритм (Java порт)

### Основная формула расчета Z

```csharp
float GetCorrectZValue(x, y, z):
    // 1. Базовое фокусное расстояние (BeamConfig.java line 119-121)
    focalLengthMm = sqrt(x² + y² + (focalLengthMm + z)²)
    focalLengthMicron = focalLengthMm * 1000

    // 2. Добавляем смещение от диаметра (BeamConfig.java line 105-107, 199-202)
    if (EnableDiameterChange):
        lensTravelMicron = rayleighLength * sqrt((d/d₀)² - 1)
        focalLengthMicron += lensTravelMicron

    // 3. Вычитаем power offset (BeamConfig.java line 108-110)
    if (EnablePowerOffset):
        if (power > maxPower * 0.15):
            powerOffset = GetPowerOffset(power)
            focalLengthMicron -= powerOffset

    // 4. Преобразуем через полином (BeamConfig.java line 111-116, 205-209)
    if (EnableZCorrection):
        f = focalLengthMicron / 1000  // мкм -> мм
        Z = a*f² + b*f + c
    else:
        Z = 0
```

### Важно: НЕТ интерполяции!

В отличие от старого алгоритма, здесь:
- ✅ Диаметр устанавливается один раз (как `DIAMETER` operation в Java)
- ✅ Используется для всех точек региона
- ❌ НЕТ линейной интерполяции между точками

## 🔧 Отладочные статические поля

Для проверки промежуточных значений в `TestUdmBuilder`:

```csharp
TestUdmBuilder.FocalLengthMm;        // Базовое фокусное расстояние (мм)
TestUdmBuilder.FocalLengthMicron;    // После всех коррекций (мкм)
TestUdmBuilder.LensTravelMicron;     // Смещение от диаметра (мкм)
TestUdmBuilder.PowerOffsetMicrons;   // Смещение от мощности (мкм)
TestUdmBuilder.ZFinal;               // Итоговая Z координата (мм)
```

## 📝 Конфигурация

Файл `scanator_config_test.json` содержит:

```json
{
  "beamConfig": {
    "minBeamDiameterMicron": 63.1,      // Минимальный диаметр (фокус)
    "wavelengthNano": 1070.0,            // Длина волны лазера
    "rayleighLengthMicron": 1863.0,      // Длина Рэлея
    "m2": 1.553,                         // Качество луча
    "focalLengthMm": 538.46              // Фокусное расстояние линзы
  },
  "thirdAxisConfig": {
    "afactor": 0.0,                      // Квадратичный коэффициент
    "bfactor": 0.013879796,              // Линейный коэффициент
    "cfactor": -7.4747047                // Константа
  },
  "functionSwitcherConfig": {
    "enableDiameterChange": true,        // Включить коррекцию диаметра
    "enableZCorrection": true,           // Включить Z коррекцию
    "enablePowerOffset": true,           // Включить power offset
    "enablePowerCorrection": true        // Включить коррекцию мощности
  }
}
```

## ⚠️ Важные замечания

1. **Полином Z-коррекции** - Линейный (a=0), преобразует фокусное расстояние в Z координату
2. **Power offset** - Работает только при мощности > 15% от максимальной
3. **Расфокусировка** - При d > 1.5*d₀ теряется значительная интенсивность
4. **Диапазон Z** - Рекомендуется [-0.5, 0.5] мм

## 🎯 Результаты тестов

После запуска создаются UDM файлы в папке `UdmBinFiles/`:
- `SinglePoint_<guid>.bin` - Автоматический расчет Z
- `SinglePoint_ManualZ_<guid>.bin` - Ручная Z координата

Эти файлы можно загрузить в сканер для реального тестирования на оборудовании.

## 📚 Ссылки на исходный Java код

- **UdmProducer.java** - `hans-dev/Hans4Java/src/org/iiv/hlssystem/multi/UdmProducer.java`
- **BeamConfig.java** - `hans-dev/Hans4Java/src/org/iiv/hans4java/controlCardProfiles/BeamConfig.java`
